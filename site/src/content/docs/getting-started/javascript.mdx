---
title: JavaScript
description: Оживите Bootstrap с помощью наших дополнительных плагинов JavaScript. Узнайте о каждом плагине, наших данных и параметрах программного API и многом другом.
toc: true
---

## Индивидуальный или скомпилированный

Плагины можно включать по отдельности (используя отдельный `js/dist/*.js` Bootstrap) или все сразу, используя `bootstrap.js` или минифицированный `bootstrap.min.js` (не включайте оба).

Если вы используете сборщик (Webpack, Parcel, Vite…), вы можете использовать файлы `/js/dist/*.js`, которые готовы к UMD.

## Использование с фреймворками JavaScript

В то время как Bootstrap CSS можно использовать с любым фреймворком, **Bootstrap JavaScript не полностью совместим с фреймворками JavaScript, такими как React, Vue и Angular**, которые предполагают полное знание DOM. И Bootstrap, и фреймворк могут попытаться изменить один и тот же элемент DOM, что приведет к ошибкам, таким как выпадающие списки, которые застряли в «открытом» положении.

Лучшей альтернативой для тех, кто использует этот тип фреймворков, является использование специфичного для фреймворка пакета **вместо** Bootstrap JavaScript. Вот некоторые из самых популярных вариантов:

- React: [React Bootstrap](https://react-bootstrap.github.io/)
  <Callout>
  **Попробуйте сами!** Загрузите исходный код и рабочую демонстрацию для использования Bootstrap с React, Next.js и React Bootstrap из [репозитория twbs/examples](https://github.com/twbs/examples/tree/main/react-nextjs). Вы также можете [открыть пример в StackBlitz](https://stackblitz.com/github/twbs/examples/tree/main/react-nextjs?file=src%2Fpages%2Findex.tsx).
  </Callout>
- Vue: [BootstrapVue](https://bootstrap-vue.org/) (Bootstrap 4)
- Vue 3: [BootstrapVueNext](https://bootstrap-vue-next.github.io/bootstrap-vue-next/) (Bootstrap 5, в настоящее время в альфа-версии)
- Angular: [ng-bootstrap](https://ng-bootstrap.github.io/) или [ngx-bootstrap](https://valor-software.com/ngx-bootstrap)

## Использование Bootstrap как модуля

<Callout>
**Попробуйте сами!** Загрузите исходный код и рабочую демоверсию для использования Bootstrap в качестве модуля ES из [репозитория twbs/examples](https://github.com/twbs/examples/tree/main/sass-js-esm). Вы также можете [открыть пример в StackBlitz](https://stackblitz.com/github/twbs/examples/tree/main/sass-js-esm?file=index.html).
</Callout>

Мы предоставляем версию Bootstrap, построенную как `ESM` (`bootstrap.esm.js` и `bootstrap.esm.min.js`), которая позволяет Вам использовать Bootstrap в качестве модуля в Вашем браузере, если Ваши [целевые браузеры поддерживают его](https://caniuse.com/es6-module).

```html
<script type="module">
  import { Toast } from 'bootstrap.esm.min.js'

  Array.from(document.querySelectorAll('.toast'))
    .forEach(toastNode => new Toast(toastNode))
</script>
```

По сравнению с JS-упаковщиками, использование ESM в браузере требует от вас использования полного пути и имени файла вместо имени модуля. [Подробнее о модулях JS в браузере.](https://v8.dev/features/modules#specifiers) Вот почему мы используем `'bootstrap.esm.min.js'` вместо `'bootstrap'` выше. Однако это еще больше усложняется нашей зависимостью от Popper, которая импортирует Popper в наш JavaScript следующим образом:

```js
import * as Popper from "@popperjs/core"
```

Если вы попробуете сделать это как есть, вы увидите ошибку в консоли, подобную следующей:

```text
Uncaught TypeError: Failed to resolve module specifier "@popperjs/core". Relative references must start with either "/", "./", or "../".
```

Чтобы исправить это, вы можете использовать `importmap` для разрешения произвольных имен модулей для завершения путей. Если ваши [целевые браузеры](https://caniuse.com/?search=importmap) не поддерживают `importmap`, вам нужно будет использовать проект [es-module-shims](https://github.com/guybedford/es-module-shims). Вот как это работает для Bootstrap и Popper:

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="[[config:cdn.css]]" rel="stylesheet" integrity="[[config:cdn.css_hash]]" crossorigin="anonymous">
    <title>Здравствуй, модульность!</title>
  </head>
  <body>
    <h1>Здравствуй, модульность!</h1>
    <button id="popoverButton" type="button" class="btn btn-primary btn-lg" data-bs-toggle="popover" title="ESM in Browser" data-bs-content="Bang!">Пользовательское всплывающее окно</button>

    <script async src="https://cdn.jsdelivr.net/npm/es-module-shims@1/dist/es-module-shims.min.js" crossorigin="anonymous"></script>
    <script type="importmap">
    {
      "imports": {
        "@popperjs/core": "[[config:cdn.popper_esm]]",
        "bootstrap": "https://cdn.jsdelivr.net/npm/bootstrap@[[config:current_version]]/dist/js/bootstrap.esm.min.js"
      }
    }
    </script>
    <script type="module">
      import * as bootstrap from 'bootstrap'

      new bootstrap.Popover(document.getElementById('popoverButton'))
    </script>
  </body>
</html>
```

## Зависимости

Некоторые плагины и компоненты CSS зависят от других плагинов. Если вы включаете плагины по отдельности, обязательно проверьте наличие этих зависимостей в документации.

Наши раскрывающиеся списки, всплывающие окна и подсказки также зависят от [Popper](https://popper.js.org/docs/v2/).

## Атрибуты данных

Почти все плагины Bootstrap можно включать и настраивать только через HTML с атрибутами данных (наш предпочтительный способ использования функций JavaScript). Обязательно **используйте только один набор атрибутов данных для одного элемента** (например, вы не можете вызвать всплывающую подсказку и модальное окно с одной и той же кнопки).

<JsDataAttributes />

## Селекторы

Мы используем собственные методы `querySelector` и `querySelectorAll` для запроса элементов DOM из соображений производительности, поэтому вы должны использовать [допустимые селекторы](https://www.w3.org/TR/CSS21/syndata.html#value-def-identifier). Если вы используете специальные селекторы, такие как `collapse:Example`, обязательно избегайте их.

## События

Bootstrap предоставляет пользовательские события для большинства уникальных действий плагинов. Как правило, они представлены в форме инфинитива и причастия прошедшего времени — где инфинитив (например, `show`) срабатывает в начале события, а его причастие прошедшего времени (например, `shown`) срабатывает по завершении действия.

Все инфинитивные события обеспечивают функциональность [`preventDefault()`](https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault). Это дает возможность остановить выполнение действия до его начала. Возврат false из обработчика событий также автоматически вызовет `preventDefault()`.

```js
const myModal = document.querySelector('#myModal')

myModal.addEventListener('show.bs.modal', event => {
  return event.preventDefault() // останавливает показ модального окна
})
```

## Программный API

Все конструкторы принимают необязательный объект опций или ничего (что запускает плагин с его поведением по умолчанию):

```js
const myModalEl = document.querySelector('#myModal')
const modal = new bootstrap.Modal(myModalEl) // initialized with defaults

const configObject = { keyboard: false }
const modal1 = new bootstrap.Modal(myModalEl, configObject) // инициализируется без клавиатуры
```

Если вы хотите получить конкретный экземпляр плагина, каждый плагин предоставляет метод `getInstance`. Например, чтобы получить экземпляр напрямую из элемента:

```js
bootstrap.Popover.getInstance(myPopoverEl)
```

Этот метод вернет `null`, если экземпляр не инициирован для запрошенного элемента.

В качестве альтернативы можно использовать `getOrCreateInstance` для получения экземпляра, связанного с элементом DOM, или создания нового, если он не был инициализирован.

```js
bootstrap.Popover.getOrCreateInstance(myPopoverEl, configObject)
```

Если экземпляр не был инициализирован, он может принять и использовать необязательный объект конфигурации в качестве второго аргумента.

### Селекторы CSS в конструкторах

В дополнение к методам `getInstance` и `getOrCreateInstance`, все конструкторы плагинов могут принимать элемент DOM или допустимый [селектор CSS](#selectors) в качестве первого аргумента. Элементы плагина находятся с помощью метода `querySelector`, так как наши плагины поддерживают только один элемент.

```js
const modal = new bootstrap.Modal('#myModal')
const dropdown = new bootstrap.Dropdown('[data-bs-toggle="dropdown"]')
const offcanvas = bootstrap.Offcanvas.getInstance('#myOffcanvas')
const alert = bootstrap.Alert.getOrCreateInstance('#myAlert')
```

### Асинхронные функции и переходы

Все программные методы API являются **асинхронными** и возвращаются вызывающей стороне после начала перехода, но **до его завершения**. Чтобы выполнить действие после завершения перехода, вы можете прослушать соответствующее событие.

```js
const myCollapseEl = document.querySelector('#myCollapse')

myCollapseEl.addEventListener('shown.bs.collapse', event => {
  // Действие, выполняемое после разворачивания сворачиваемой области
})
```

Кроме того, вызов метода **переходного компонента будет игнорироваться**.

```js
const myCarouselEl = document.querySelector('#myCarousel')
const carousel = bootstrap.Carousel.getInstance(myCarouselEl) // Получить экземпляр карусели

myCarouselEl.addEventListener('slid.bs.carousel', event => {
  carousel.to('2') // Перейдет к слайду 2, как только завершится переход к слайду 1
})

carousel.to('1') // Начнет скользить к слайду 1 и вернется к вызывающему абоненту
carousel.to('2') // !! Будет проигнорирован, т.к. переход к слайду 1 не завершен !!
```

#### Метод `dispose`

Хотя может показаться правильным использовать метод `dispose` сразу после `hide()`, это приведет к неверным результатам. Вот пример проблемного использования:

```js
const myModal = document.querySelector('#myModal')
myModal.hide() // это асинхронно

myModal.addEventListener('shown.bs.hidden', event => {
  myModal.dispose()
})
```

### Настройки по умолчанию

Вы можете изменить настройки плагина по умолчанию, изменив объект `Constructor.Default` плагина:

```js
// изменяет значение по умолчанию для параметра `keyboard` модального плагина на false
bootstrap.Modal.Default.keyboard = false
```

## Методы и свойства

Каждый плагин Bootstrap предоставляет следующие методы и статические свойства.

<BsTable class="table">
| Метод | Описание |
| --- | --- |
| `dispose` | Уничтожает модальное окно элемента. (Удаляет сохраненные данные в элементе DOM) |
| `getInstance` | *Статический* метод, позволяющий получить модальный экземпляр, связанный с элементом DOM. |
| `getOrCreateInstance` | *Статический* метод, позволяющий получить модальный экземпляр, связанный с элементом DOM, или создать новый, если он не был инициализирован. |
</BsTable>

<BsTable class="table">
| Статическое свойство | Описание |
| --- | --- |
| `NAME` | Возвращает имя плагина. (Пример: `bootstrap.Tooltip.NAME`) |
| `VERSION` | Версию каждого плагина Bootstrap можно получить через свойство `VERSION` конструктора плагина (Пример: `bootstrap.Tooltip.VERSION`) |
</BsTable>

## Санитайзер

Всплывающие подсказки и всплывающие окна используют наше встроенное средство очистки для очистки параметров, которые принимают HTML.

Значение по умолчанию для `allowList` следующее:

<JsDocs name="allow-list" file="js/src/util/sanitizer.js" removeIndentation={false} />

Если вы хотите добавить новые значения в этот `allowList` по умолчанию, вы можете сделать следующее:

```js
const myDefaultAllowList = bootstrap.Tooltip.Default.allowList

// Чтобы разрешить элементы таблицы
myDefaultAllowList.table = []

// Чтобы разрешить элементы td и атрибуты параметров данных в элементах td
myDefaultAllowList.td = ['data-bs-option']

// Вы можете отправить собственное регулярное выражение для проверки своих атрибутов.
// Будьте осторожны, чтобы Ваши регулярные выражения были слишком слабыми
const myCustomRegex = /^data-my-app-[\w-]+/
myDefaultAllowList['*'].push(myCustomRegex)
```

Если вы хотите обойти наше дезинфицирующее средство, потому что предпочитаете использовать специальную библиотеку, например [DOMPurify](https://www.npmjs.com/package/dompurify), вам следует сделать следующее:

```js
const yourTooltipEl = document.querySelector('#yourTooltip')
const tooltip = new bootstrap.Tooltip(yourTooltipEl, {
  sanitizeFn(content) {
    return DOMPurify.sanitize(content)
  }
})
```

## Опциональное использование jQuery

**Вам не нужен jQuery в Bootstrap 5**, но вы все еще можете использовать наши компоненты с jQuery. Если Bootstrap обнаружит `jQuery` в объекте `window`, он добавит все наши компоненты в систему плагинов jQuery. Это позволяет вам делать следующее:

```js
// to enable tooltips with the default configuration
$('[data-bs-toggle="tooltip"]').tooltip()

// to initialize tooltips with given configuration
$('[data-bs-toggle="tooltip"]').tooltip({
  boundary: 'clippingParents',
  customClass: 'myClass'
})

// to trigger the `show` method
$('#myTooltip').tooltip('show')
```

То же самое касается и других наших компонентов.

### Отсутствие конфликта

Иногда необходимо использовать плагины Bootstrap с другими UI-фреймворками. В этих обстоятельствах иногда могут возникать конфликты пространств имен. Если это произойдет, вы можете вызвать `.noConflict` для плагина, для которого вы хотите восстановить значение.

```js
const bootstrapButton = $.fn.button.noConflict() // вернуть $.fn.button к ранее присвоенному значению
$.fn.bootstrapBtn = bootstrapButton // дать $().bootstrapBtn функциональность Bootstrap
```

Bootstrap официально не поддерживает сторонние библиотеки JavaScript, такие как Prototype или jQuery UI. Несмотря на `.noConflict` и пространства имен событий, могут быть проблемы совместимости, которые вам нужно исправить самостоятельно.

### События jQuery

Bootstrap обнаружит jQuery, если `jQuery` присутствует в объекте `window` и для `<body>` не установлен атрибут `data-bs-no-jquery`. Если jQuery найден, Bootstrap будет генерировать события благодаря системе событий jQuery. Поэтому, если вы хотите прослушивать события Bootstrap, вам придется использовать методы jQuery (`.on`, `.one`) вместо `addEventListener`.

```js
$('#myTab a').on('shown.bs.tab', () => {
  // do something...
})
```

## Отключенный JavaScript

Плагины Bootstrap не имеют специального резервного варианта, когда JavaScript отключен. Если вас волнует пользовательский опыт в этом случае, используйте [`<noscript>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/noscript), чтобы объяснить ситуацию (и как снова включить JavaScript) вашим пользователям, и/или добавьте свои собственные резервные варианты.
